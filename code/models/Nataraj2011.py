import numpy as np
import pandas as pd
import joblib
import json
import time

import sklearn.metrics as metrics
from sklearn.metrics import f1_score, accuracy_score, recall_score, precision_score
from sklearn.model_selection import StratifiedKFold
from sklearn.neighbors import KNeighborsClassifier

from .Basics import MachineLearningModel
from .Data import MalImgDataset

class KNN(MachineLearningModel):
    """
    A class used to classify malware files using K-Nearest Neighbours.

    This class implements a classifier using KNN and GIST or LBP as descriptors,
    based upon Nataraj et. al. (2011) work.

    Attributes
    ----------
    path : str
        Path to malware dataset
    n_classes : int
        Number of malware families to be classified
    descriptor : str
        Algorithm name to be used as descriptor (default "GIST")
    k : int
        Number of k-nearest neighbours (default 3)
    height : int
        Height of the malware image (default 64)
    width : int
        Width of the malware image (default 64)

    Methods
    -------
    __init__(sound=None)
        Class initialization
    """

    def __init__(self, path, ext='png', descriptor='GIST', k=3, height=64, width=64):
        """
        Parameters
        ----------
        path : str
            Path to malware dataset
        descriptor : str
            Algorithm name to be used as descriptor (default "GIST")
        k : int
            Number of k-nearest neighbours (default 3)
        height : int
            Height of the malware image (default 64)
        width : int
            Width of the malware image (default 64)
        """

        self.k = k
        self.descriptor = descriptor
        self.height = height
        self.width = width

        if self.descriptor == 'GIST':
            model_filename = 'knn_gist_model_file'
        elif self.descriptor == 'LBP':
            model_filename = 'knn_lbp_model_file'
        else:
            raise Exception('Unknown descriptor for KNN model.')

        # Init parent class
        MachineLearningModel.__init__(self, path, model_filename, ext=ext)

    def train(self,
              n_folds=1,
              split_method='nataraj',
              use_subset=False,
              test_npz=None,
              augmenters=None):
        self.logger.info("** Training started!")

        # Set augmentation methods to be used
        self.augmenters = augmenters

        self.data_handler.split_dataset(n_folds=n_folds, split_method=split_method, use_subset=use_subset)

        avg_acc  = []
        avg_f1   = []
        avg_time = []
        test_acc = 0

        inj_avg_acc  = []
        inj_avg_f1   = []
        inj_avg_time = []

        for fold in range(n_folds):
            self.logger.info("===== FOLD {} =====".format(fold))

            self.data_handler.compute_fold_split()

            start = time.time()

            clf = KNeighborsClassifier(self.k, weights='distance')

            train_data = self.data_handler.get_train_data(merge_validation=True)

            np.random.shuffle(train_data)

            self.logger.warning("Starting feature extraction.")
            if self.descriptor == 'GIST':
                train_X_features, train_y = self.data_handler.extract_GIST_features(
                    train_data,
                    self.height,
                    self.width,
                    augmenters=self.augmenters
                )
            elif self.descriptor == 'LBP':
                train_X_features, train_y = self.data_handler.extract_LBP_features(
                    train_data,
                    self.height,
                    self.width,
                )

            self.logger.warning(f"Fitting classifier with {set(train_y)} and {train_X_features.shape} samples.")
            clf.fit(train_X_features, train_y)
            fold_model = self.save_model(clf, fold)

            end = time.time()

            train_time = int(end - start)

            test_set = self.data_handler.get_test_data()
            test_acc, test_f1, test_time  = self._test(fold,
                                                       fold_model,
                                                       test_set)

            self.results[fold+1] = {
                "acc": test_acc,
                "f1": test_f1,
                "train_time": train_time,
                "test_time": test_time
            }
            total_time = train_time + test_time
            avg_acc.append(test_acc)
            avg_f1.append(test_f1)
            avg_time.append(total_time)

            for npz_path in test_npz:
                # Test with injected data
                test_acc, test_f1, test_time  = self._test_injected(npz_path,
                                                                    fold,
                                                                    clf,
                                                                    binarize=None)
                self.results[f"{fold+1}_injected"] = {
                    "path": npz_path,
                    "acc": test_acc,
                    "f1": test_f1,
                    "test_time": test_time
                }
                inj_avg_acc.append(test_acc)
                inj_avg_f1.append(test_f1)
                inj_avg_time.append(test_time)

        print_str = "** Finished training in {}s! Average ACC: {}; STD DEV {};".format(
            np.mean(avg_time),
            np.mean(avg_acc),
            np.std(avg_acc)
        )
        self.logger.warning(print_str)
        self.data_handler.save_to_log(print_str  + '\n')
        self.data_handler.save_to_log(json.dumps(self.results))

        return

    def _test(self, fold, model_path, test_data):
        self.logger.info("** Testing started!")

        result_file = self.data_handler.create_file(
            name="test_results_{}.txt".format(fold),
        )

        test_set_size = len(test_data)
        labels = []
        predictions = []
        scores = []

        _model = self.load_model(model_path)

        start_test_predict = time.time()

        # Testing
        if self.descriptor == 'GIST':
            X_test, y_test = self.data_handler.extract_GIST_features(
                test_data,
                self.height,
                self.width,
            )
        elif self.descriptor == 'LBP':
            X_test, y_test = self.data_handler.extract_LBP_features(
                test_data,
                self.height,
                self.width,
            )

        predictions = _model.predict(X_test) # output is labels and not indices

        end_test_predict = time.time()

        scores = _model.predict_proba(X_test)

        labels = y_test

        f1 = metrics.f1_score(y_test, predictions, average="weighted")
        acc = accuracy_score(y_test, predictions)
        difference = int(end_test_predict - start_test_predict)

        print_str = "\t\t *TEST* SET => Time: {}s; ACC: {:.4f}; F1: {:.4f}".format(difference, acc, f1)

        self.logger.info(print_str)
        result_file.write(print_str)

        self.logger.info(f" Saving npz: metrics_test_results_{fold}.npz")
        np.savez(f"{self.data_handler.tmp_output_path}/metrics_test_results_{fold}.npz",
            y_true=labels,
            y=predictions,
            p=scores,
            acc=acc,
            f1=f1)

        self.logger.info("** Testing finished!")

        return acc, f1, difference


    def _test_injected(self, npz, fold, clf, binarize=None):

        data = np.load(npz, mmap_mode='r', allow_pickle=True)

        total_samples = data['y'].shape[0]
        MBS=4096

        result_file_name = "{}_{}".format(npz.split('/')[-1].split('.')[0], fold)
        result_file = self.data_handler.create_file(
            name=f"test_results_{result_file_name}.txt",
        )

        self.logger.warning(f"Testing against {total_samples} samples from {npz}.")

        labels = []
        predictions = []
        scores = []

        # https://stackoverflow.com/questions/59216547/python-npzfile-objects-are-very-slow
        m_X = data['X']
        m_y = data['y']

        start_test_predict = time.time()

        for idx in range(0, total_samples, MBS):

            batchX = m_X[idx:idx+MBS]
            batchY = m_y[idx:idx+MBS]
            size = batchX.shape[0]

            batch_data = list(zip(batchX, batchY))

            if self.descriptor == 'GIST':
                X, _ = self.data_handler.extract_GIST_features(
                    batch_data,
                    self.height,
                    self.width,
                    from_data=True
                )
            elif self.descriptor == 'LBP':
                X, _ = self.data_handler.extract_LBP_features(
                    batch_data,
                    self.height,
                    self.width,
                )


            predicted_labels = clf.predict(X) # output is labels and not indices
            probs = clf.predict_proba(X)

            print(predicted_labels.shape, probs.shape)

            for _id in range(size):

                if binarize in [None, False]:
                    y = batchY[_id]
                else:
                    y = 1 if batchY[_id] == binarize else 0

                _y    = predicted_labels[_id]
                score = probs[_id]

                labels.append(int(y))
                predictions.append(_y)
                scores.append(score)

                result_file.write("{}, {}\n".format(y,
                                                    _y))

        end_test_predict = time.time()

        acc = metrics.accuracy_score(labels, predictions)
        f1 = metrics.f1_score(labels, predictions, average="weighted")
        # precision, recall, thresholds = metrics.precision_recall_curve(labels, scores)

        difference = int(end_test_predict - start_test_predict)

        print_str = "\t\t *TEST* SET (INJECTED) => Time: {}s; ACC: {:.4f}; F1: {:.4f}".format(difference, acc, f1)

        self.logger.info(print_str)
        result_file.write(print_str)

        self.logger.info(f" Saving npz: {result_file_name}.npz")
        np.savez(f"{self.data_handler.tmp_output_path}/metrics_{result_file_name}.npz",
                 y_true=labels,
                 y=predictions,
                 p=scores,
                 acc=acc,
                 f1=f1)
                #  precision=precision,
                #  recall=recall,
                #  thresholds=thresholds)

        self.logger.info("** Injection Testing finished!")

        return acc, f1, difference


    def test(self, _model, test_data):
        self.logger.info("** Testing started!")

        # Testing
        if self.descriptor == 'GIST':
            X_test, y_test = self.data_handler.extract_GIST_features(
                test_data,
                self.height,
                self.width,
            )
        elif self.descriptor == 'LBP':
            X_test, y_test = self.data_handler.extract_LBP_features(
                test_data,
                self.height,
                self.width,
            )

        y_predict = _model.predict(X_test) # output is labels and not indices
        acc = accuracy_score(y_test, y_predict)
        self.logger.info("\t\t *TEST* SET => ACC: {:.4f}".format(acc))

        self.logger.info("** Testing finished!")


    def train_and_test(self, test_path):
        self.logger.info("** Training started!")

        self.data_handler.split_dataset()
        self.data_handler.compute_fold_split()
        train_data = self.data_handler.get_all_data()
        self.logger.info("Shape of training data: {}".format(len(train_data)))

        train_X_features, train_y = self.data_handler.extract_GIST_features(
            train_data,
            self.height,
            self.width,
        )

        clf = KNeighborsClassifier(self.k, weights='distance')
        clf.fit(train_X_features, train_y)
        #self.save_model(clf, fold)

        self.logger.info("** Training finished!")

        #####################################################################

        self.logger.info("** Testing started!")

        test_data_handler = MalImgDataset(test_path)
        test_data_handler.split_dataset()
        test_data_handler.compute_fold_split()
        test_data = test_data_handler.get_all_data()

        result_file = self.data_handler.create_file(
            name="test_results_test_only.txt",
        )

        self.logger.info("Shape of testing data: {}".format(len(test_data)))

        X_test, y_test = self.data_handler.extract_GIST_features(
            test_data,
            self.height,
            self.width,
        )


        y_predict = clf.predict(X_test) # output is labels and not indices

        for i in range(len(y_test)):
            result_file.write("{}, {}\n".format(y_test[i], y_predict[i]))

        acc = accuracy_score(y_test, y_predict)
        print_str = "\t\t *TEST* SET => ACC: {:.4f}\n".format(acc)
        self.logger.info(print_str)
        result_file.write(print_str)

        self.logger.info("** Testing finished!")

    def save_model(self, model, fold):
        path = self.get_tmp_model_path() + '_' + str(fold)
        joblib.dump(model, path)
        return path

    def load_model(self, path):
        return joblib.load(path)
